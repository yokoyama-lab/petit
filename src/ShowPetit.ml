(* show functions generated by the BNF converter *)

open AbsPetit

(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string = 
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b
    
let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf -> 
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf -> 
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf -> 
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys 
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)
let rec showIdent (Ident i) : showable = s2s "Ident " >> showString i


let rec showStm (e:stm) : showable = match e with
       Ass (ident, exp) -> s2s "Ass" >> c2s ' ' >> c2s '(' >> showIdent ident  >> s2s ", " >>  showExp exp >> c2s ')'
  |    Con (stm0, stm) -> s2s "Con" >> c2s ' ' >> c2s '(' >> showStm stm0  >> s2s ", " >>  showStm stm >> c2s ')'
  |    For (exp, stm) -> s2s "For" >> c2s ' ' >> c2s '(' >> showExp exp  >> s2s ", " >>  showStm stm >> c2s ')'


and showExp (e:exp) : showable = match e with
       Zer  -> s2s "Zer" 
  |    Var ident -> s2s "Var" >> c2s ' ' >> c2s '(' >> showIdent ident >> c2s ')'
  |    Suc exp -> s2s "Suc" >> c2s ' ' >> c2s '(' >> showExp exp >> c2s ')'



